#!/usr/bin/env bash
set -euo pipefail

JQ_BIN="${SHIPLOG_JQ_BIN:-/usr/local/bin/jq}"
TRUST_REF="${SHIPLOG_TRUST_REF:-refs/_shiplog/trust/root}"
POLICY_REF="${SHIPLOG_POLICY_REF:-refs/_shiplog/policy/current}"
REQUIRE_SEPARATE_SIGNERS="${SHIPLOG_REQUIRE_SEPARATE_SIGNERS:-1}"
# Optional relaxations: allow missing trust/policy when signatures are not required.
# Defaults keep strict behavior for CI/tests.
ALLOW_MISSING_TRUST="${SHIPLOG_ALLOW_MISSING_TRUST:-0}"
ALLOW_MISSING_POLICY="${SHIPLOG_ALLOW_MISSING_POLICY:-0}"

if ! command -v "$JQ_BIN" >/dev/null 2>&1; then
  if command -v jq >/dev/null 2>&1; then
    JQ_BIN="$(command -v jq)"
  else
    echo "shiplog pre-receive: jq not found at $JQ_BIN" >&2
    exit 1
  fi
fi

TMP_ROOT="$(mktemp -d)"
trap 'rm -rf "$TMP_ROOT"' EXIT
SIGNERS_FILE=""
CURRENT_TRUST_TIP=""
CURRENT_TRUST_JSON=""
CURRENT_POLICY_JSON=""

error() {
  echo "❌ shiplog: $*" >&2
  exit 1
}

load_trust_state() {
  local commit="$1"
  [ -n "$commit" ] || return 0
  CURRENT_TRUST_TIP="$commit"
  CURRENT_TRUST_JSON=$(git show "$commit:trust.json" 2>/dev/null || true)
  [ -n "$CURRENT_TRUST_JSON" ] || error "trust ref $TRUST_REF is missing trust.json"
  "$JQ_BIN" -e '
    .version == 1 and
    (.threshold | type == "number" and . >= 1) and
    (.maintainers | type == "array" and length >= 1)
  ' <<<"$CURRENT_TRUST_JSON" >/dev/null 2>&1 || error "trust.json failed validation"

  local signers_blob
  signers_blob=$(git show "$commit:allowed_signers" 2>/dev/null || true)
  if [ "$REQUIRE_SEPARATE_SIGNERS" = "1" ]; then
    [ -n "$signers_blob" ] || error "trust ref $TRUST_REF missing allowed_signers"
  fi
  if [ -n "$signers_blob" ]; then
    SIGNERS_FILE="$TMP_ROOT/allowed_signers"
    printf '%s' "$signers_blob" > "$SIGNERS_FILE"
    chmod 600 "$SIGNERS_FILE"
  else
    SIGNERS_FILE=""
  fi
}

load_policy_state() {
  local commit="$1"
  [ -n "$commit" ] || return 0
  CURRENT_POLICY_JSON=$(git show "$commit:.shiplog/policy.json" 2>/dev/null || true)
  [ -n "$CURRENT_POLICY_JSON" ] || return 0
  "$JQ_BIN" -e '
    .version == 1 and (.require_signed | type == "boolean")
  ' <<<"$CURRENT_POLICY_JSON" >/dev/null 2>&1 || error "policy.json failed validation"
}

get_policy_require_signed() {
  local env="$1"
  "$JQ_BIN" -r --arg env "$env" '(.deployment_requirements[$env].require_signed // .require_signed // false) | tostring' <<<"$CURRENT_POLICY_JSON"
}

get_policy_authors() {
  local env="$1"
  "$JQ_BIN" -r --arg env "$env" '
    if (.authors.default_allowlist? != null or .authors.env_overrides?) then
      [
        (.authors.default_allowlist // []),
        (.authors.env_overrides.default // []),
        (.authors.env_overrides[$env] // [])
      ]
    else
      [
        (.authors.default // []),
        (.authors[$env] // []),
        (.authors.env_overrides.default // []),
        (.authors.env_overrides[$env] // [])
      ]
    end
    | flatten
    | map(select(. != null and . != ""))
    | unique
    | join(" ")
  ' <<<"$CURRENT_POLICY_JSON"
}

ensure_fast_forward() {
  local old="$1" new="$2" ref="$3"
  if [ "$old" = "0000000000000000000000000000000000000000" ]; then
    return 0
  fi
  git merge-base --is-ancestor "$old" "$new" >/dev/null 2>&1 || error "$ref is not a fast-forward update"
}

validate_trust_update() {
  local old="$1" new="$2"
  ensure_fast_forward "$old" "$new" "$TRUST_REF"
  load_trust_state "$new"
  # Run shared verifier if available (preferred for both modes)
  if [ -x "$GIT_DIR/../scripts/shiplog-verify-trust.sh" ]; then
    (cd "$GIT_DIR/.." && ./scripts/shiplog-verify-trust.sh --old "$old" --new "$new" --ref "$TRUST_REF") || error "trust verification failed"
  else
    # Fallback: require at least one valid signature and block threshold>1 by default
    enforce_trust_threshold "$new"
  fi
}

validate_policy_update() {
  local old="$1" new="$2"
  ensure_fast_forward "$old" "$new" "$POLICY_REF"
load_policy_state "$new"
}

# Enforce that the new trust commit is properly signed and (eventually) co-signed
enforce_trust_threshold() {
  local commit="$1"
  # Optionally require a valid signature on the trust commit itself
  case "${SHIPLOG_REQUIRE_SIGNED_TRUST:-0}" in
    1|true|yes|on)
      if [ -n "$SIGNERS_FILE" ]; then
        GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git verify-commit "$commit" >/dev/null 2>&1 || error "trust commit $commit has missing or invalid signature"
      else
        git verify-commit "$commit" >/dev/null 2>&1 || error "trust commit $commit failed signature verification"
      fi
      ;;
    *) : ;;
  esac

  # Enforce threshold semantics progressively.
  # NOTE: Git commits carry a single embedded signature. Multi-maintainer co-signing requires a
  # higher-level pattern (e.g., a linear chain of N commits over the same tree, or detached
  # attestations stored in the trust tree). Until that is implemented, we fail closed by default
  # when threshold > 1, with an escape hatch for staged rollouts.
  local threshold
  threshold=$(printf '%s' "$CURRENT_TRUST_JSON" | "$JQ_BIN" -r '.threshold // 1')
  case "$threshold" in
    ''|null) threshold=1 ;;
  esac
  if ! printf '%s' "$threshold" | grep -Eq '^[1-9][0-9]*$'; then
    error "trust.json invalid threshold value: $threshold"
  fi

  if [ "$threshold" -gt 1 ]; then
    if [ "${SHIPLOG_ALLOW_TRUST_THRESHOLD_UNENFORCED:-0}" != "1" ]; then
      error "trust threshold $threshold not yet enforced by hook; set SHIPLOG_ALLOW_TRUST_THRESHOLD_UNENFORCED=1 to allow temporarily"
    fi
  fi
}

read_commit_json() {
  local commit="$1"
  git show -s --format=%B "$commit" | awk '/^---/{flag=1;next}flag'
}

get_commit_seq() {
  local commit="$1"
  local json
  json=$(read_commit_json "$commit") || return 1
  [ -n "$json" ] || return 1
  "$JQ_BIN" -r '.seq' <<<"$json"
}

ensure_author_allowed() {
  local author="$1" allowlist="$2"
  [ -z "$allowlist" ] && return 0
  for entry in $allowlist; do
    [ "$entry" = "$author" ] && return 0
  done
  error "author <$author> not allowed for journal"
}

ensure_commit_signed_if_required() {
  local commit="$1" require_signed="$2"
  if [ "$require_signed" != "true" ] && [ "$require_signed" != "1" ]; then
    return 0
  fi
  if ! git cat-file commit "$commit" | grep -q '^gpgsig ' ; then
    error "commit $commit missing required signature"
  fi
  if [ -n "$SIGNERS_FILE" ]; then
    GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git verify-commit "$commit" >/dev/null 2>&1 || error "signature for $commit not accepted"
  else
    git verify-commit "$commit" >/dev/null 2>&1 || error "signature verification failed for $commit"
  fi
}

validate_journal_commit() {
  local env="$1" commit="$2" require_signed="$3" allowlist="$4"
  local json
  json=$(read_commit_json "$commit")
  [ -n "$json" ] || error "commit $commit missing structured trailer"

  local declared_env declared_parent seq trust_oid status
  declared_env=$("$JQ_BIN" -r '.env // empty' <<<"$json")
  seq=$("$JQ_BIN" -r '.seq' <<<"$json")
  trust_oid=$("$JQ_BIN" -r '.trust_oid // empty' <<<"$json")
  declared_parent=$("$JQ_BIN" -r '.journal_parent // ""' <<<"$json")
  status=$("$JQ_BIN" -r '.status // empty' <<<"$json")

  [ "$declared_env" = "$env" ] || error "commit $commit declares env $declared_env but ref is $env"
  if [ -n "$CURRENT_TRUST_TIP" ]; then
    [ "$trust_oid" = "$CURRENT_TRUST_TIP" ] || error "commit $commit trust_oid $trust_oid does not match current trust $CURRENT_TRUST_TIP"
  else
    # If trust is missing and allowed, do not enforce trust_oid equality.
    if [ "$ALLOW_MISSING_TRUST" != "1" ]; then
      error "trust ref $TRUST_REF missing"
    fi
  fi
  [[ "$seq" =~ ^[0-9]+$ ]] || error "commit $commit has invalid seq"
  [ -n "$status" ] || error "commit $commit missing status"

  local actual_parent
  actual_parent=$(git show -s --format='%P' "$commit")
  if [ -z "$actual_parent" ]; then
    actual_parent=""
  fi
  if [[ "$actual_parent" =~ \  ]]; then
    error "commit $commit is a merge; journal entries must be linear"
  fi

  if [ -z "$actual_parent" ]; then
    [ "$declared_parent" = "" ] || error "commit $commit declared parent $declared_parent but has none"
    [ "$seq" -eq 0 ] || error "commit $commit must have seq 0 for initial entry"
  else
    [ "$declared_parent" = "$actual_parent" ] || error "commit $commit parent mismatch (declared $declared_parent vs actual $actual_parent)"
    local prev_seq
    prev_seq=$(get_commit_seq "$actual_parent") || error "parent commit $actual_parent missing seq"
    [[ "$prev_seq" =~ ^[0-9]+$ ]] || error "parent commit $actual_parent has invalid seq"
    local expected
    expected=$((prev_seq + 1))
    [ "$seq" -eq "$expected" ] || error "commit $commit seq $seq expected $expected"
  fi

  local author
  author=$(git show -s --format='%ae' "$commit")
  ensure_author_allowed "$author" "$allowlist"
  ensure_commit_signed_if_required "$commit" "$require_signed"
}

validate_journal_updates() {
  local env="$1" old="$2" new="$3"
  ensure_fast_forward "$old" "$new" "refs/_shiplog/journal/$env"
  local require_signed allowlist
  if [ -n "$CURRENT_POLICY_JSON" ]; then
    require_signed=$(get_policy_require_signed "$env")
    allowlist=$(get_policy_authors "$env")
  else
    if [ "$ALLOW_MISSING_POLICY" = "1" ]; then
      require_signed=false
      allowlist=""
    else
      error "policy ref $POLICY_REF missing"
    fi
  fi

  local range
  if [ "$old" = "0000000000000000000000000000000000000000" ]; then
    range="$new"
  else
    range="$new"" ""^$old"
  fi

  git rev-list --reverse $range | while read -r commit; do
    [ -n "$commit" ] || continue
    validate_journal_commit "$env" "$commit" "$require_signed" "$allowlist"
  done
}

CURRENT_TRUST_TIP=$(git rev-parse -q --verify "$TRUST_REF" 2>/dev/null || true)
if [ -n "$CURRENT_TRUST_TIP" ]; then
  load_trust_state "$CURRENT_TRUST_TIP"
else
  CURRENT_TRUST_JSON=""
  SIGNERS_FILE=""
fi

CURRENT_POLICY_TIP=$(git rev-parse -q --verify "$POLICY_REF" 2>/dev/null || true)
if [ -n "$CURRENT_POLICY_TIP" ]; then
  load_policy_state "$CURRENT_POLICY_TIP"
else
  CURRENT_POLICY_JSON=""
fi

while read -r old_sha new_sha refname; do
  if [ "$new_sha" = "0000000000000000000000000000000000000000" ]; then
    continue
  fi
  case "$refname" in
    "$TRUST_REF")
      validate_trust_update "$old_sha" "$new_sha"
      ;;
    "$POLICY_REF")
      validate_policy_update "$old_sha" "$new_sha"
      ;;
    refs/_shiplog/journal/*)
      env="${refname#refs/_shiplog/journal/}"
      validate_journal_updates "$env" "$old_sha" "$new_sha"
      ;;
    refs/_shiplog/anchors/*)
      ensure_fast_forward "$old_sha" "$new_sha" "$refname"
      ;;
    *)
      ;;
  esac
done

exit 0
