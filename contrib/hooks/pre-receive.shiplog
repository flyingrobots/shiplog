#!/usr/bin/env bash
set -euo pipefail

JQ_BIN="${SHIPLOG_JQ_BIN:-/usr/local/bin/jq}"
TRUST_REF="${SHIPLOG_TRUST_REF:-refs/_shiplog/trust/root}"
POLICY_REF="${SHIPLOG_POLICY_REF:-refs/_shiplog/policy/current}"
REQUIRE_SEPARATE_SIGNERS="${SHIPLOG_REQUIRE_SEPARATE_SIGNERS:-1}"
# Optional relaxations: allow missing trust/policy when signatures are not required.
# Defaults keep strict behavior for CI/tests.
ALLOW_MISSING_TRUST="${SHIPLOG_ALLOW_MISSING_TRUST:-0}"
ALLOW_MISSING_POLICY="${SHIPLOG_ALLOW_MISSING_POLICY:-0}"

if ! command -v "$JQ_BIN" >/dev/null 2>&1; then
  if command -v jq >/dev/null 2>&1; then
    JQ_BIN="$(command -v jq)"
  else
    echo "shiplog pre-receive: jq not found at $JQ_BIN" >&2
    exit 1
  fi
fi

TMP_ROOT="$(mktemp -d)"
trap 'rm -rf "$TMP_ROOT"' EXIT
SIGNERS_FILE=""
CURRENT_TRUST_TIP=""
CURRENT_TRUST_JSON=""
CURRENT_POLICY_JSON=""

error() {
  echo "❌ shiplog: $*" >&2
  exit 1
}

debug_enabled() {
  case "$(printf '%s' "${SHIPLOG_DEBUG_SSH_VERIFY:-0}" | tr '[:upper:]' '[:lower:]')" in
    1|true|yes|on) return 0 ;;
    *) return 1 ;;
  esac
}
dbg() { debug_enabled && echo "shiplog[debug]: $*" >&2 || true; }

load_trust_state() {
  local commit="$1"
  [ -n "$commit" ] || return 0
  CURRENT_TRUST_TIP="$commit"
  CURRENT_TRUST_JSON=$(git show "$commit:trust.json" 2>/dev/null || true)
  [ -n "$CURRENT_TRUST_JSON" ] || error "trust ref $TRUST_REF is missing trust.json"
  "$JQ_BIN" -e '
    .version == 1 and
    (.threshold | type == "number" and . >= 1) and
    (.maintainers | type == "array" and length >= 1)
  ' <<<"$CURRENT_TRUST_JSON" >/dev/null 2>&1 || error "trust.json failed validation"

  local signers_blob
  signers_blob=$(git show "$commit:allowed_signers" 2>/dev/null || true)
  if [ "$REQUIRE_SEPARATE_SIGNERS" = "1" ]; then
    [ -n "$signers_blob" ] || error "trust ref $TRUST_REF missing allowed_signers"
  fi
  if [ -n "$signers_blob" ]; then
    SIGNERS_FILE="$TMP_ROOT/allowed_signers"
    printf '%s' "$signers_blob" > "$SIGNERS_FILE"
    chmod 600 "$SIGNERS_FILE"
    if debug_enabled; then
      principals=$(awk '{print $1}' "$SIGNERS_FILE" | paste -sd, -)
      dbg "allowed_signers principals=[${principals}]"
    fi
  else
    SIGNERS_FILE=""
  fi
}

load_policy_state() {
  local commit="$1"
  [ -n "$commit" ] || return 0
  CURRENT_POLICY_JSON=$(git show "$commit:.shiplog/policy.json" 2>/dev/null || true)
  [ -n "$CURRENT_POLICY_JSON" ] || return 0
  "$JQ_BIN" -e '
    .version == 1 and (.require_signed | type == "boolean")
  ' <<<"$CURRENT_POLICY_JSON" >/dev/null 2>&1 || error "policy.json failed validation"
}

get_policy_require_signed() {
  local env="$1"
  "$JQ_BIN" -r --arg env "$env" '(.deployment_requirements[$env].require_signed // .require_signed // false) | tostring' <<<"$CURRENT_POLICY_JSON"
}

get_policy_authors() {
  local env="$1"
  "$JQ_BIN" -r --arg env "$env" '
    if (.authors.default_allowlist? != null or .authors.env_overrides?) then
      [
        (.authors.default_allowlist // []),
        (.authors.env_overrides.default // []),
        (.authors.env_overrides[$env] // [])
      ]
    else
      [
        (.authors.default // []),
        (.authors[$env] // []),
        (.authors.env_overrides.default // []),
        (.authors.env_overrides[$env] // [])
      ]
    end
    | flatten
    | map(select(. != null and . != ""))
    | unique
    | join(" ")
  ' <<<"$CURRENT_POLICY_JSON"
}

ensure_fast_forward() {
  local old="$1" new="$2" ref="$3"
  if [ "$old" = "0000000000000000000000000000000000000000" ]; then
    return 0
  fi
  git merge-base --is-ancestor "$old" "$new" >/dev/null 2>&1 || error "$ref is not a fast-forward update"
}

validate_trust_update() {
  local old="$1" new="$2"
  ensure_fast_forward "$old" "$new" "$TRUST_REF"
  load_trust_state "$new"
  # Run shared verifier if available (preferred for both modes)
  if [ -x "$GIT_DIR/../scripts/shiplog-verify-trust.sh" ]; then
    (cd "$GIT_DIR/.." && ./scripts/shiplog-verify-trust.sh --old "$old" --new "$new" --ref "$TRUST_REF") || error "trust verification failed"
  else
    # Fallback: require at least one valid signature and block threshold>1 by default
    enforce_trust_threshold "$new"
  fi
}

validate_policy_update() {
  local old="$1" new="$2"
  ensure_fast_forward "$old" "$new" "$POLICY_REF"
load_policy_state "$new"
}

# Enforce that the new trust commit is properly signed and (eventually) co-signed
enforce_trust_threshold() {
  local commit="$1"
  # Trust-commit signature gate:
  # - SHIPLOG_REQUIRE_SIGNED_TRUST defaults to 0 (signature checks skipped)
  # - For production, set to 1/true/yes/on to enforce signed trust commits
  #   (leaving it off reduces integrity of trust updates)
  # Normalize gate safely under set -u
  local gate gate_mode
  gate=$(printf '%s' "${SHIPLOG_REQUIRE_SIGNED_TRUST:-0}" | tr '[:upper:]' '[:lower:]')
  gate_mode=$(printf '%s' "${SHIPLOG_REQUIRE_SIGNED_TRUST_MODE:-commit}" | tr '[:upper:]' '[:lower:]')
  local gpg_format="${SHIPLOG_GPG_FORMAT:-ssh}"
  dbg "require_signed: enabled=$gate mode=$gate_mode gpg.format=$gpg_format"
  local commit_ok=0 commit_checked=0
  case "$gate" in
    1|true|yes|on)
      case "$gate_mode" in
        commit)
          commit_checked=1
          if [ -n "$SIGNERS_FILE" ]; then
            if GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed; signature block follows"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
              error "trust commit $commit has missing or invalid signature"
            fi
          else
            if git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed (no allowed_signers); signature block follows"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
              error "trust commit $commit failed signature verification"
            fi
          fi
          ;;
        either)
          commit_checked=1
          if [ -n "$SIGNERS_FILE" ]; then
            if GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed under 'either'; will attempt attestation fallback if applicable"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
            fi
          else
            if git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed under 'either' (no allowed_signers)"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
            fi
          fi
          ;;
        attestation)
          : ;; # handled below
        *)
          dbg "unknown SHIPLOG_REQUIRE_SIGNED_TRUST_MODE=$gate_mode; defaulting to commit"
          commit_checked=1
          if ! git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
            error "trust commit $commit failed signature verification"
          fi
          commit_ok=1
          ;;
      esac
      ;;
    *) : ;;
  esac

  # Enforce threshold semantics progressively.
  # NOTE: Git commits carry a single embedded signature. Multi-maintainer co-signing requires a
  # higher-level pattern (e.g., a linear chain of N commits over the same tree, or detached
  # attestations stored in the trust tree). Until that is implemented, we fail closed by default
  # when threshold > 1, with an escape hatch for staged rollouts.
  local threshold
  threshold=$(printf '%s' "$CURRENT_TRUST_JSON" | "$JQ_BIN" -r '.threshold // 1')
  case "$threshold" in
    ''|null) threshold=1 ;;
  esac
  if ! printf '%s' "$threshold" | grep -Eq '^[1-9][0-9]*$'; then
    error "trust.json invalid threshold value: $threshold"
  fi

  if [ "$threshold" -gt 1 ]; then
    if [ "${SHIPLOG_ALLOW_TRUST_THRESHOLD_UNENFORCED:-0}" != "1" ]; then
      # Attempt minimal attestation enforcement if requested or as 'either' fallback
      if [ "$gate_mode" = "attestation" ] || { [ "$gate_mode" = "either" ] && [ "$commit_checked" = "1" ] && [ "$commit_ok" != "1" ]; }; then
        attestation_verify "$commit" "$threshold" || error "verified fewer than $threshold attestations"
        return 0
      fi
      error "trust threshold $threshold not yet enforced by hook; set SHIPLOG_ALLOW_TRUST_THRESHOLD_UNENFORCED=1 to allow temporarily"
    fi
  fi
  # If threshold==1, allow success when commit gate satisfied or not requested. Under 'either',
  # if commit failed, try attestation fallback.
  if [ "$threshold" -eq 1 ] && [ "$gate" != "0" ] && [ "$gate_mode" = "either" ] && [ "$commit_checked" = "1" ] && [ "$commit_ok" != "1" ]; then
    attestation_verify "$commit" 1 || error "no valid attestation found for threshold=1"
  fi
}

# Minimal attestation verification for the fallback path in this hook
attestation_verify() {
  local commit="$1" threshold="$2"
  command -v ssh-keygen >/dev/null 2>&1 || return 1
  [ -n "$SIGNERS_FILE" ] || return 1
  # Collect attestation sigs under .shiplog/trust_sigs/
  mapfile -t sigs < <(git ls-tree -r --name-only "$commit" | awk '/^\.shiplog\/trust_sigs\//{print}')
  local nsigs=${#sigs[@]}
  dbg "attestation(fallback): found $nsigs signature file(s)"
  [ "$nsigs" -ge 1 ] || return 1
  # Build canonical base payload
  local oid_trust oid_sigs base trust_id tmp_in verified=0 principals_seen=""
  trust_id=$(printf '%s' "$CURRENT_TRUST_JSON" | "$JQ_BIN" -r '.id // "shiplog-trust-root"')
  oid_trust=$(git ls-tree "$commit" trust.json | awk '{print $3}')
  oid_sigs=$(git ls-tree "$commit" allowed_signers | awk '{print $3}')
  if [ -n "$oid_sigs" ]; then
    base=$(printf '100644 blob %s\ttrust.json\n100644 blob %s\tallowed_signers\n' "$oid_trust" "$oid_sigs" | git mktree)
  else
    base=$(printf '100644 blob %s\ttrust.json\n' "$oid_trust" | git mktree)
  fi
  tmp_in=$(mktemp)
  printf 'shiplog-trust-tree-v1\n%s\n%s\n%s\n' "$base" "$trust_id" "$threshold" >"$tmp_in"
  for path in "${sigs[@]}"; do
    principal=$(basename "$path" | sed 's/\.sig$//')
    sigblob=$(git show "$commit:$path" 2>/dev/null || true)
    [ -n "$sigblob" ] || continue
    sigfile=$(mktemp)
    printf '%s' "$sigblob" > "$sigfile"
    if ssh-keygen -Y verify -n shiplog-trust -f "$SIGNERS_FILE" -I "$principal" -s "$sigfile" < "$tmp_in" >/dev/null 2>&1; then
      case " $principals_seen " in *" $principal "*) : ;; *) principals_seen="$principals_seen $principal"; verified=$((verified+1));; esac
    fi
    rm -f "$sigfile"
  done
  rm -f "$tmp_in"
  dbg "attestation(fallback): verified=$verified threshold=$threshold"
  [ "$verified" -ge "$threshold" ]
}

read_commit_json() {
  local commit="$1"
  git show -s --format=%B "$commit" | awk '/^---/{flag=1;next}flag'
}

get_commit_seq() {
  local commit="$1"
  local json
  json=$(read_commit_json "$commit") || return 1
  [ -n "$json" ] || return 1
  "$JQ_BIN" -r '.seq' <<<"$json"
}

ensure_author_allowed() {
  local author="$1" allowlist="$2"
  [ -z "$allowlist" ] && return 0
  for entry in $allowlist; do
    [ "$entry" = "$author" ] && return 0
  done
  error "author <$author> not allowed for journal"
}

ensure_commit_signed_if_required() {
  local commit="$1" require_signed="$2"
  if [ "$require_signed" != "true" ] && [ "$require_signed" != "1" ]; then
    return 0
  fi
  if ! git cat-file commit "$commit" | grep -q '^gpgsig ' ; then
    error "commit $commit missing required signature"
  fi
  local gpg_format="${SHIPLOG_GPG_FORMAT:-ssh}"
  if [ -n "$SIGNERS_FILE" ]; then
    GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1 || error "signature for $commit not accepted"
  else
    git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1 || error "signature verification failed for $commit"
  fi
}

validate_journal_commit() {
  local env="$1" commit="$2" require_signed="$3" allowlist="$4"
  local json
  json=$(read_commit_json "$commit")
  [ -n "$json" ] || error "commit $commit missing structured trailer"

  local declared_env declared_parent seq trust_oid status
  declared_env=$("$JQ_BIN" -r '.env // empty' <<<"$json")
  seq=$("$JQ_BIN" -r '.seq' <<<"$json")
  trust_oid=$("$JQ_BIN" -r '.trust_oid // empty' <<<"$json")
  declared_parent=$("$JQ_BIN" -r '.journal_parent // ""' <<<"$json")
  status=$("$JQ_BIN" -r '.status // empty' <<<"$json")

  [ "$declared_env" = "$env" ] || error "commit $commit declares env $declared_env but ref is $env"
  if [ -n "$CURRENT_TRUST_TIP" ]; then
    [ "$trust_oid" = "$CURRENT_TRUST_TIP" ] || error "commit $commit trust_oid $trust_oid does not match current trust $CURRENT_TRUST_TIP"
  else
    # If trust is missing and allowed, do not enforce trust_oid equality.
    if [ "$ALLOW_MISSING_TRUST" != "1" ]; then
      error "trust ref $TRUST_REF missing"
    fi
  fi
  [[ "$seq" =~ ^[0-9]+$ ]] || error "commit $commit has invalid seq"
  [ -n "$status" ] || error "commit $commit missing status"

  local actual_parent
  actual_parent=$(git show -s --format='%P' "$commit")
  if [ -z "$actual_parent" ]; then
    actual_parent=""
  fi
  if [[ "$actual_parent" =~ \  ]]; then
    error "commit $commit is a merge; journal entries must be linear"
  fi

  if [ -z "$actual_parent" ]; then
    [ "$declared_parent" = "" ] || error "commit $commit declared parent $declared_parent but has none"
    [ "$seq" -eq 0 ] || error "commit $commit must have seq 0 for initial entry"
  else
    [ "$declared_parent" = "$actual_parent" ] || error "commit $commit parent mismatch (declared $declared_parent vs actual $actual_parent)"
    local prev_seq
    prev_seq=$(get_commit_seq "$actual_parent") || error "parent commit $actual_parent missing seq"
    [[ "$prev_seq" =~ ^[0-9]+$ ]] || error "parent commit $actual_parent has invalid seq"
    local expected
    expected=$((prev_seq + 1))
    [ "$seq" -eq "$expected" ] || error "commit $commit seq $seq expected $expected"
  fi

  local author
  author=$(git show -s --format='%ae' "$commit")
  ensure_author_allowed "$author" "$allowlist"
  ensure_commit_signed_if_required "$commit" "$require_signed"
}

validate_journal_updates() {
  local env="$1" old="$2" new="$3"
  ensure_fast_forward "$old" "$new" "refs/_shiplog/journal/$env"
  local require_signed allowlist
  if [ -n "$CURRENT_POLICY_JSON" ]; then
    require_signed=$(get_policy_require_signed "$env")
    allowlist=$(get_policy_authors "$env")
  else
    if [ "$ALLOW_MISSING_POLICY" = "1" ]; then
      require_signed=false
      allowlist=""
    else
      error "policy ref $POLICY_REF missing"
    fi
  fi

  local range
  if [ "$old" = "0000000000000000000000000000000000000000" ]; then
    range="$new"
  else
    range="$new"" ""^$old"
  fi

  git rev-list --reverse $range | while read -r commit; do
    [ -n "$commit" ] || continue
    validate_journal_commit "$env" "$commit" "$require_signed" "$allowlist"
  done
}

CURRENT_TRUST_TIP=$(git rev-parse -q --verify "$TRUST_REF" 2>/dev/null || true)
if [ -n "$CURRENT_TRUST_TIP" ]; then
  load_trust_state "$CURRENT_TRUST_TIP"
else
  CURRENT_TRUST_JSON=""
  SIGNERS_FILE=""
fi

CURRENT_POLICY_TIP=$(git rev-parse -q --verify "$POLICY_REF" 2>/dev/null || true)
if [ -n "$CURRENT_POLICY_TIP" ]; then
  load_policy_state "$CURRENT_POLICY_TIP"
else
  CURRENT_POLICY_JSON=""
fi

while read -r old_sha new_sha refname; do
  if [ "$new_sha" = "0000000000000000000000000000000000000000" ]; then
    continue
  fi
  case "$refname" in
    "$TRUST_REF")
      validate_trust_update "$old_sha" "$new_sha"
      ;;
    "$POLICY_REF")
      validate_policy_update "$old_sha" "$new_sha"
      ;;
    refs/_shiplog/journal/*)
      env="${refname#refs/_shiplog/journal/}"
      validate_journal_updates "$env" "$old_sha" "$new_sha"
      ;;
    refs/_shiplog/anchors/*)
      ensure_fast_forward "$old_sha" "$new_sha" "$refname"
      ;;
    *)
      ;;
  esac
done

exit 0
