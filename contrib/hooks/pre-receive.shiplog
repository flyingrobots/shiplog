#!/usr/bin/env bash
set -euo pipefail

POLICY_REF="${SHIPLOG_POLICY_REF:-refs/_shiplog/policy/current}"

if ! command -v jq >/dev/null 2>&1; then
  echo "shiplog pre-receive: jq command required for JSON policy parsing. Install jq and try again." >&2
  exit 1
fi
read_policy() {
  git show "$POLICY_REF:.shiplog/policy.json" 2>/dev/null || return 1
}

parse_policy_for_env() {
  local env="$1"
  local policy_content="$2"
  local rs="" asf="" authors=""

  if [ -z "$policy_content" ]; then
    echo "ERROR: No policy content provided" >&2
    return 1
  fi

  if ! rs=$(jq -r '.require_signed // empty' <<<"$policy_content" 2>/dev/null); then
    rs=""
  fi
  if [ -n "$rs" ]; then
    echo "require_signed=${rs}"
  fi

  if ! asf=$(jq -r '.allow_ssh_signers_file // empty' <<<"$policy_content" 2>/dev/null); then
    asf=""
  fi
  if [ -n "$asf" ]; then
    echo "allowed_signers_file=${asf}"
  fi

  if ! authors=$(jq -r --arg env "$env" '
      [
        (.authors.default_allowlist // []),
        (.authors.env_overrides.default // []),
        (.authors.env_overrides[$env] // [])
      ]
      | flatten
      | map(select(. != null and . != ""))
      | unique
      | join(" ")
    ' <<<"$policy_content" 2>/dev/null); then
    authors=""
  fi
  if [ -n "$authors" ]; then
    echo "authors=${authors}"
  fi
}

policy_content=$(read_policy || true)
if [ -z "$policy_content" ]; then
  echo "shiplog pre-receive: policy ref $POLICY_REF not found" >&2
  exit 1
fi

check_commits() {
  local env="$1" old="$2" new="$3"
  local parsed
  parsed=$(printf "%s" "$policy_content" | parse_policy_for_env "$env") || parsed=""
  local require_signed=""
  local allowed_signers=""
  local allowed_authors=""
  while IFS='=' read -r key value; do
    case "$key" in
      require_signed)
        case "${value,,}" in
          1|true|yes|y|on) require_signed=1 ;;
          0|false|no|n|off) require_signed=0 ;;
          *) 
            echo "❌ shiplog: Invalid require_signed value: '$value'. Valid values: 1/0, true/false, yes/no, y/n, on/off" >&2
            exit 1
            ;;
        esac
        ;;
      allowed_signers_file) allowed_signers="$value" ;;
      authors) allowed_authors="$value" ;;
    esac
  done <<<"$parsed"

  local range_args=()
  if [ "$old" = "0000000000000000000000000000000000000000" ]; then
    range_args=("$new")
  else
    range_args=("$new" "^$old")
  fi

  local commit
  while read -r commit; do
    [ -n "$commit" ] || continue
    author=$(git show -s --format='%ae' "$commit")
    if [ -n "$allowed_authors" ]; then
      allowed=0
      for a in $allowed_authors; do
        if [ "$a" = "$author" ]; then
          allowed=1
          break
        fi
      done
      if [ "$allowed" -ne 1 ]; then
        echo "❌ shiplog: author <$author> not allowed for $env" >&2
        exit 1
      fi
    fi

    if [ "$require_signed" = "1" ]; then
      if ! git cat-file commit "$commit" | grep -q '^gpgsig '; then
        echo "❌ shiplog: commit $commit missing signature" >&2
        exit 1
      fi
      if [ -n "$allowed_signers" ] && [ -f "$allowed_signers" ]; then
        if ! GIT_SSH_ALLOWED_SIGNERS="$allowed_signers" git verify-commit "$commit" >/dev/null 2>&1; then
          echo "❌ shiplog: signature for $commit not accepted by $allowed_signers" >&2
          exit 1
        fi
      else
        if ! git verify-commit "$commit" >/dev/null 2>&1; then
          echo "❌ shiplog: signature verification failed for $commit" >&2
          exit 1
        fi
      fi
    fi
  done < <(git rev-list "${range_args[@]}")
}

while read -r old_sha new_sha refname; do
  [[ "$new_sha" = 0000000000000000000000000000000000000000 ]] && continue
  case "$refname" in
    refs/_shiplog/journal/*)
      env="${refname#refs/_shiplog/journal/}"
      check_commits "$env" "$old_sha" "$new_sha"
      ;;
    refs/_shiplog/anchors/*)
      env="${refname#refs/_shiplog/anchors/}"
      check_commits "$env" "$old_sha" "$new_sha"
      ;;
    *)
      ;;
  esac
done

exit 0
