#!/usr/bin/env bash
set -euo pipefail

JQ_BIN="${SHIPLOG_JQ_BIN:-/usr/local/bin/jq}"
TRUST_REF="${SHIPLOG_TRUST_REF:-refs/_shiplog/trust/root}"
POLICY_REF="${SHIPLOG_POLICY_REF:-refs/_shiplog/policy/current}"
REQUIRE_SEPARATE_SIGNERS="${SHIPLOG_REQUIRE_SEPARATE_SIGNERS:-1}"
# Optional relaxations: allow missing trust/policy when signatures are not required.
# Defaults keep strict behavior for CI/tests.
ALLOW_MISSING_TRUST="${SHIPLOG_ALLOW_MISSING_TRUST:-0}"
ALLOW_MISSING_POLICY="${SHIPLOG_ALLOW_MISSING_POLICY:-0}"
HOOK_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
# SECURITY WARNING: HOOK_DIR, POLICY_VALIDATOR_BIN, and POLICY_VALIDATOR_FILTER
# influence server-side execution. Only trusted administrators on the receiving
# host may set SHIPLOG_POLICY_VALIDATE_BIN or SHIPLOG_POLICY_VALIDATOR; untrusted
# overrides can lead to arbitrary command execution. Deployments should leave
# these unset or pin them via configuration management.
POLICY_VALIDATOR_BIN="${SHIPLOG_POLICY_VALIDATE_BIN:-}"
POLICY_VALIDATOR_FILTER="${SHIPLOG_POLICY_VALIDATOR:-}"
# Canonical jq filter lives at scripts/lib/policy_validate.jq.
SAFE_PREFIXES=()
if [ -n "${SHIPLOG_HOME:-}" ]; then
  SAFE_PREFIXES+=("${SHIPLOG_HOME}")
fi
SAFE_PREFIXES+=("$HOOK_DIR" "$HOOK_DIR/../lib")

canonicalize_path() {
  local target="$1"
  if command -v realpath >/dev/null 2>&1; then
    realpath "$target" 2>/dev/null
  elif command -v python3 >/dev/null 2>&1; then
    python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$target" 2>/dev/null
  elif command -v perl >/dev/null 2>&1; then
    perl -MCwd=abs_path -e 'print abs_path(shift)' "$target" 2>/dev/null
  elif command -v readlink >/dev/null 2>&1; then
    readlink -f "$target" 2>/dev/null
  else
    return 1
  fi
}

is_group_or_world_writable() {
  # Fallback order covers: python (preferred), perl, GNU stat, BSD stat, ls parsing.
  # Each branch exists so the hook works across diverse distros and busybox images.
  local path="$1"
  # Prefer python for portable bitmask checks when available.
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$path" <<'PY'
import os, stat, sys
try:
    mode = os.stat(sys.argv[1]).st_mode
except OSError:
    sys.exit(2)
mask = stat.S_IWGRP | stat.S_IWOTH
sys.exit(0 if (mode & mask) else 1)
PY
    case $? in
      0) return 0 ;; # group/world writable
      1) return 1 ;; # safe
    esac
  # Fallback to perl when python is unavailable (common in minimal images).
  elif command -v perl >/dev/null 2>&1; then
    perl -e 'use Fcntl qw(:mode); my $m = (stat $ARGV[0])[2]; exit(($m & (S_IWGRP|S_IWOTH)) ? 0 : 1);' "$path"
    case $? in
      0) return 0 ;;
      1) return 1 ;;
    esac
  # GNU/BSD stat variants cover most remaining distros.
  elif command -v stat >/dev/null 2>&1; then
    if stat --format '%a' "$path" >/dev/null 2>&1; then
      local perm
      perm=$(stat --format '%a' "$path" 2>/dev/null || true)
      if [ -n "$perm" ]; then
        local mode=$((10#$perm))
        local group=$(((mode / 10) % 10))
        local other=$((mode % 10))
        if [ $((group & 2)) -ne 0 ] || [ $((other & 2)) -ne 0 ]; then
          return 0
        fi
        return 1
      fi
    elif stat -f '%Lp' "$path" >/dev/null 2>&1; then
      local perm
      perm=$(stat -f '%Lp' "$path" 2>/dev/null || true)
      if [ -n "$perm" ]; then
        local mode=$((10#$perm))
        local group=$(((mode / 10) % 10))
        local other=$((mode % 10))
        if [ $((group & 2)) -ne 0 ] || [ $((other & 2)) -ne 0 ]; then
          return 0
        fi
        return 1
      fi
    fi
  # As a last resort, parse ls output (limited but better than nothing).
  elif command -v ls >/dev/null 2>&1; then
    local perm
    perm=$(ls -ld "$path" 2>/dev/null | awk '{print $1}')
    # Format like -rwxr-xr-x
    if [ -n "$perm" ]; then
      local group_write=${perm:5:1}
      local other_write=${perm:8:1}
      if [ "$group_write" = "w" ] || [ "$other_write" = "w" ]; then
        return 0
      fi
      return 1
    fi
  fi
  # Conservative default: treat unknown modes as unsafe to fail closed.
  return 0
}

path_is_safe() {
  local candidate="$1"
  local canonical
  canonical=$(canonicalize_path "$candidate") || return 1
  local prefix
  local match=1
  for prefix in "${SAFE_PREFIXES[@]}"; do
    [ -n "$prefix" ] || continue
    local canon_prefix
    canon_prefix=$(canonicalize_path "$prefix") || continue
    case "$canonical" in
      "$canon_prefix"|"$canon_prefix"/*)
        match=0
        break
        ;;
    esac
  done
  if [ "$match" -ne 0 ]; then
    return 1
  fi
  if is_group_or_world_writable "$canonical"; then
    return 1
  fi
  return 0
}

if ! command -v "$JQ_BIN" >/dev/null 2>&1; then
  if command -v jq >/dev/null 2>&1; then
    JQ_BIN="$(command -v jq)"
  else
    echo "shiplog pre-receive: jq not found at $JQ_BIN" >&2
    exit 1
  fi
fi

TMP_ROOT="$(mktemp -d)"
trap 'rm -rf "$TMP_ROOT"' EXIT
SIGNERS_FILE=""
CURRENT_TRUST_TIP=""
CURRENT_TRUST_JSON=""
CURRENT_POLICY_JSON=""

find_policy_validator_bin() {
  local log_unsafe=${1:-}
  local candidates=(
    "$POLICY_VALIDATOR_BIN"
    "${SHIPLOG_HOME:-}/scripts/policy/validate.sh"
    "$HOOK_DIR/policy/validate.sh"
  )
  local candidate canonical
  for candidate in "${candidates[@]}"; do
    if [ -z "$candidate" ]; then
      continue
    fi
    if [ "$candidate" = "$POLICY_VALIDATOR_BIN" ] && [ ! -e "$candidate" ]; then
      echo "shiplog: ignoring POLICY_VALIDATOR_BIN (missing): $candidate" >&2
      continue
    fi
    if [ -n "$candidate" ] && [ -f "$candidate" ] && [ -x "$candidate" ]; then
      canonical=$(canonicalize_path "$candidate") || continue
      if ! path_is_safe "$canonical"; then
        if [ -n "$log_unsafe" ] && [ "$candidate" = "$POLICY_VALIDATOR_BIN" ]; then
          echo "shiplog: ignoring unsafe POLICY_VALIDATOR_BIN path: $candidate" >&2
        fi
        continue
      fi
      printf '%s' "$canonical"
      return 0
    fi
  done
  return 1
}

ensure_policy_validator_filter() {
  local filter="${POLICY_VALIDATOR_FILTER}"
  local candidate canonical
  if [ -n "$filter" ] && [ -f "$filter" ]; then
    canonical=$(canonicalize_path "$filter") || canonical=""
    if [ -n "$canonical" ] && path_is_safe "$canonical"; then
      printf '%s' "$canonical"
      return 0
    else
      echo "shiplog: ignoring unsafe POLICY_VALIDATOR_FILTER path: $filter" >&2
    fi
  elif [ -n "$filter" ]; then
    echo "shiplog: ignoring POLICY_VALIDATOR_FILTER (missing): $filter" >&2
  fi
  local candidates=(
    "${SHIPLOG_HOME:-}/scripts/lib/policy_validate.jq"
    "$HOOK_DIR/../lib/policy_validate.jq"
    "$HOOK_DIR/policy_validate.jq"
  )
  for candidate in "${candidates[@]}"; do
    if [ -n "$candidate" ] && [ -f "$candidate" ]; then
      canonical=$(canonicalize_path "$candidate") || continue
      path_is_safe "$canonical" || continue
      printf '%s' "$canonical"
      return 0
    fi
  done
  echo "shiplog: policy validator filter not found (expected scripts/lib/policy_validate.jq)" >&2
  return 1
}

# SECURITY MODEL:
# - Runs inside the server-side pre-receive hook with elevated privileges.
# - Policy JSON is attacker-controlled until validated; hook must fail closed.
# - Only canonical validators rooted beneath SAFE_PREFIXES are ever executed.
# - POLICY_VALIDATOR_BIN / POLICY_VALIDATOR_FILTER overrides are accepted only
#   from trusted administrators and are rejected when unsafe.
# - jq/script failures abort the hook to avoid publishing inconsistent policy.
run_policy_validator() {
  local json="$1"
  local validator output status filter
  if validator=$(find_policy_validator_bin log); then
    output=$(printf '%s\n' "$json" | "$validator" --stdin 2>&1)
    status=$?
    if [ "$status" -eq 0 ]; then
      return 0
    elif [ "$status" -eq 1 ]; then
      [ -n "$output" ] && dbg "$output"
      error "policy.json failed validation"
    else
      [ -n "$output" ] && dbg "$output"
      error "policy validator exited with status $status"
    fi
  fi
  if ! filter=$(ensure_policy_validator_filter); then
    error "policy validator filter not found; expected scripts/lib/policy_validate.jq"
  fi
  output=$(printf '%s\n' "$json" | "$JQ_BIN" -r -f "$filter" 2>&1)
  status=$?
  if [ "$status" -ne 0 ]; then
    [ -n "$output" ] && dbg "$output"
    error "policy.json validation: jq execution failed"
  fi
  if [ -n "$output" ]; then
    dbg "$output"
    error "policy.json failed validation"
  fi
}

error() {
  echo "❌ shiplog: $*" >&2
  exit 1
}

debug_enabled() {
  case "$(printf '%s' "${SHIPLOG_DEBUG_SSH_VERIFY:-0}" | tr '[:upper:]' '[:lower:]')" in
    1|true|yes|on) return 0 ;;
    *) return 1 ;;
  esac
}
dbg() { debug_enabled && echo "shiplog[debug]: $*" >&2 || true; }

load_trust_state() {
  local commit="$1"
  [ -n "$commit" ] || return 0
  CURRENT_TRUST_TIP="$commit"
  CURRENT_TRUST_JSON=$(git show "$commit:trust.json" 2>/dev/null || true)
  [ -n "$CURRENT_TRUST_JSON" ] || error "trust ref $TRUST_REF is missing trust.json"
  "$JQ_BIN" -e '
    .version == 1 and
    (.threshold | type == "number" and . >= 1) and
    (.maintainers | type == "array" and length >= 1)
  ' <<<"$CURRENT_TRUST_JSON" >/dev/null 2>&1 || error "trust.json failed validation"

  local signers_blob
  signers_blob=$(git show "$commit:allowed_signers" 2>/dev/null || true)
  if [ "$REQUIRE_SEPARATE_SIGNERS" = "1" ]; then
    [ -n "$signers_blob" ] || error "trust ref $TRUST_REF missing allowed_signers"
  fi
  if [ -n "$signers_blob" ]; then
    SIGNERS_FILE="$TMP_ROOT/allowed_signers"
    printf '%s' "$signers_blob" > "$SIGNERS_FILE"
    chmod 600 "$SIGNERS_FILE"
    if debug_enabled; then
      principals=$(awk '{print $1}' "$SIGNERS_FILE" | paste -sd, -)
      dbg "allowed_signers principals=[${principals}]"
    fi
  else
    SIGNERS_FILE=""
  fi
}

load_policy_state() {
  local commit="$1"
  [ -n "$commit" ] || return 0
  CURRENT_POLICY_JSON=$(git show "$commit:.shiplog/policy.json" 2>/dev/null || true)
  [ -n "$CURRENT_POLICY_JSON" ] || return 0
  run_policy_validator "$CURRENT_POLICY_JSON"
}


get_policy_require_signed() {
  local env="$1"
  "$JQ_BIN" -r --arg env "$env" '(.deployment_requirements[$env].require_signed // .require_signed // false) | tostring' <<<"$CURRENT_POLICY_JSON"
}

get_policy_authors() {
  local env="$1"
  "$JQ_BIN" -r --arg env "$env" '
    if (.authors.default_allowlist? != null or .authors.env_overrides?) then
      [
        (.authors.default_allowlist // []),
        (.authors.env_overrides.default // []),
        (.authors.env_overrides[$env] // [])
      ]
    else
      [
        (.authors.default // []),
        (.authors[$env] // []),
        (.authors.env_overrides.default // []),
        (.authors.env_overrides[$env] // [])
      ]
    end
    | flatten
    | map(select(. != null and . != ""))
    | unique
    | join(" ")
  ' <<<"$CURRENT_POLICY_JSON"
}

ensure_fast_forward() {
  local old="$1" new="$2" ref="$3"
  if [ "$old" = "0000000000000000000000000000000000000000" ]; then
    return 0
  fi
  git merge-base --is-ancestor "$old" "$new" >/dev/null 2>&1 || error "$ref is not a fast-forward update"
}

validate_trust_update() {
  local old="$1" new="$2"
  ensure_fast_forward "$old" "$new" "$TRUST_REF"
  load_trust_state "$new"
  # Run shared verifier if available (preferred for both modes)
  if [ -x "$GIT_DIR/../scripts/shiplog-verify-trust.sh" ]; then
    (cd "$GIT_DIR/.." && ./scripts/shiplog-verify-trust.sh --old "$old" --new "$new" --ref "$TRUST_REF") || error "trust verification failed"
  else
    # Fallback: require at least one valid signature and block threshold>1 by default
    enforce_trust_threshold "$new"
  fi
}

validate_policy_update() {
  local old="$1" new="$2"
  ensure_fast_forward "$old" "$new" "$POLICY_REF"
load_policy_state "$new"
}

# Enforce that the new trust commit is properly signed and (eventually) co-signed
enforce_trust_threshold() {
  local commit="$1"
  # Trust-commit signature gate:
  # - SHIPLOG_REQUIRE_SIGNED_TRUST defaults to 0 (signature checks skipped)
  # - For production, set to 1/true/yes/on to enforce signed trust commits
  #   (leaving it off reduces integrity of trust updates)
  # Normalize gate safely under set -u
  local gate gate_mode
  gate=$(printf '%s' "${SHIPLOG_REQUIRE_SIGNED_TRUST:-0}" | tr '[:upper:]' '[:lower:]')
  gate_mode=$(printf '%s' "${SHIPLOG_REQUIRE_SIGNED_TRUST_MODE:-commit}" | tr '[:upper:]' '[:lower:]')
  local gpg_format="${SHIPLOG_GPG_FORMAT:-ssh}"
  dbg "require_signed: enabled=$gate mode=$gate_mode gpg.format=$gpg_format"
  local commit_ok=0 commit_checked=0
  case "$gate" in
    1|true|yes|on)
      case "$gate_mode" in
        commit)
          commit_checked=1
          if [ -n "$SIGNERS_FILE" ]; then
            if GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed; signature block follows"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
              error "trust commit $commit has missing or invalid signature"
            fi
          else
            if git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed (no allowed_signers); signature block follows"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
              error "trust commit $commit failed signature verification"
            fi
          fi
          ;;
        either)
          commit_checked=1
          if [ -n "$SIGNERS_FILE" ]; then
            if GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed under 'either'; will attempt attestation fallback if applicable"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
            fi
          else
            if git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed under 'either' (no allowed_signers)"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
            fi
          fi
          ;;
        attestation)
          : ;; # handled below
        *)
          dbg "unknown SHIPLOG_REQUIRE_SIGNED_TRUST_MODE=$gate_mode; defaulting to commit"
          commit_checked=1
          if ! git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
            error "trust commit $commit failed signature verification"
          fi
          commit_ok=1
          ;;
      esac
      ;;
    *) : ;;
  esac

  # Enforce threshold semantics progressively.
  # NOTE: Git commits carry a single embedded signature. Multi-maintainer co-signing requires a
  # higher-level pattern (e.g., a linear chain of N commits over the same tree, or detached
  # attestations stored in the trust tree). Until that is implemented, we fail closed by default
  # when threshold > 1, with an escape hatch for staged rollouts.
  local threshold
  threshold=$(printf '%s' "$CURRENT_TRUST_JSON" | "$JQ_BIN" -r '.threshold // 1')
  case "$threshold" in
    ''|null) threshold=1 ;;
  esac
  if ! printf '%s' "$threshold" | grep -Eq '^[1-9][0-9]*$'; then
    error "trust.json invalid threshold value: $threshold"
  fi

  if [ "$threshold" -gt 1 ]; then
    if [ "${SHIPLOG_ALLOW_TRUST_THRESHOLD_UNENFORCED:-0}" != "1" ]; then
      # Attempt minimal attestation enforcement if requested or as 'either' fallback
      if [ "$gate_mode" = "attestation" ] || { [ "$gate_mode" = "either" ] && [ "$commit_checked" = "1" ] && [ "$commit_ok" != "1" ]; }; then
        attestation_verify "$commit" "$threshold" || error "verified fewer than $threshold attestations"
        return 0
      fi
      error "trust threshold $threshold not yet enforced by hook; set SHIPLOG_ALLOW_TRUST_THRESHOLD_UNENFORCED=1 to allow temporarily"
    fi
  fi
  # If threshold==1 and commit verification did not succeed (or attestation mode is explicitly
  # requested), attempt attestation verification as the decision-maker for this update.
  # This ensures SHIPLOG_REQUIRE_SIGNED_TRUST_MODE=attestation enforces attestations even when
  # the commit signature is absent or unaccepted.
  if [ "$threshold" -eq 1 ]; then
    if { [ "$commit_checked" = "1" ] && [ "$commit_ok" != "1" ]; } || [ "$gate_mode" = "attestation" ]; then
      attestation_verify "$commit" 1 || error "no valid attestation found for threshold=1"
    fi
  fi
}

# Minimal attestation verification for the fallback path in this hook
attestation_verify() {
  local commit="$1" threshold="$2"
  command -v ssh-keygen >/dev/null 2>&1 || return 1
  [ -n "$SIGNERS_FILE" ] || return 1
  # Collect attestation sigs under .shiplog/trust_sigs/
  mapfile -t sigs < <(git ls-tree -r --name-only "$commit" | awk '/^\.shiplog\/trust_sigs\//{print}')
  local nsigs=${#sigs[@]}
  dbg "attestation(fallback): found $nsigs signature file(s)"
  [ "$nsigs" -ge 1 ] || return 1
  # Build canonical base payload
  local oid_trust oid_sigs base trust_id tmp_in verified=0 principals_seen=""
  trust_id=$(printf '%s' "$CURRENT_TRUST_JSON" | "$JQ_BIN" -r '.id // "shiplog-trust-root"')
  oid_trust=$(git ls-tree "$commit" trust.json | awk '{print $3}')
  oid_sigs=$(git ls-tree "$commit" allowed_signers | awk '{print $3}')
  if [ -n "$oid_sigs" ]; then
    base=$(printf '100644 blob %s\ttrust.json\n100644 blob %s\tallowed_signers\n' "$oid_trust" "$oid_sigs" | git mktree)
  else
    base=$(printf '100644 blob %s\ttrust.json\n' "$oid_trust" | git mktree)
  fi
  tmp_in=$(mktemp)
  printf 'shiplog-trust-tree-v1\n%s\n%s\n%s\n' "$base" "$trust_id" "$threshold" >"$tmp_in"
  for path in "${sigs[@]}"; do
    principal=$(basename "$path" | sed 's/\.sig$//')
    sigblob=$(git show "$commit:$path" 2>/dev/null || true)
    [ -n "$sigblob" ] || continue
    sigfile=$(mktemp)
    printf '%s' "$sigblob" > "$sigfile"
    if ssh-keygen -Y verify -n shiplog-trust -f "$SIGNERS_FILE" -I "$principal" -s "$sigfile" < "$tmp_in" >/dev/null 2>&1; then
      case " $principals_seen " in *" $principal "*) : ;; *) principals_seen="$principals_seen $principal"; verified=$((verified+1));; esac
    fi
    rm -f "$sigfile"
  done
  rm -f "$tmp_in"
  dbg "attestation(fallback): verified=$verified threshold=$threshold"
  [ "$verified" -ge "$threshold" ]
}

read_commit_json() {
  local commit="$1"
  git show -s --format=%B "$commit" | awk '/^---/{flag=1;next}flag'
}

get_commit_seq() {
  local commit="$1"
  local json
  json=$(read_commit_json "$commit") || return 1
  [ -n "$json" ] || return 1
  "$JQ_BIN" -r '.seq' <<<"$json"
}

ensure_author_allowed() {
  local author="$1" allowlist="$2"
  [ -z "$allowlist" ] && return 0
  for entry in $allowlist; do
    [ "$entry" = "$author" ] && return 0
  done
  error "author <$author> not allowed for journal"
}

ensure_commit_signed_if_required() {
  local commit="$1" require_signed="$2"
  if [ "$require_signed" != "true" ] && [ "$require_signed" != "1" ]; then
    return 0
  fi
  if ! git cat-file commit "$commit" | grep -q '^gpgsig ' ; then
    error "commit $commit missing required signature"
  fi
  local gpg_format="${SHIPLOG_GPG_FORMAT:-ssh}"
  if [ -n "$SIGNERS_FILE" ]; then
    GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1 || error "signature for $commit not accepted"
  else
    git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1 || error "signature verification failed for $commit"
  fi
}

validate_journal_commit() {
  local env="$1" commit="$2" require_signed="$3" allowlist="$4"
  local json
  json=$(read_commit_json "$commit")
  [ -n "$json" ] || error "commit $commit missing structured trailer"

  local declared_env declared_parent seq trust_oid status
  declared_env=$("$JQ_BIN" -r '.env // empty' <<<"$json")
  seq=$("$JQ_BIN" -r '.seq' <<<"$json")
  trust_oid=$("$JQ_BIN" -r '.trust_oid // empty' <<<"$json")
  declared_parent=$("$JQ_BIN" -r '.journal_parent // ""' <<<"$json")
  status=$("$JQ_BIN" -r '.status // empty' <<<"$json")

  [ "$declared_env" = "$env" ] || error "commit $commit declares env $declared_env but ref is $env"
  if [ -n "$CURRENT_TRUST_TIP" ]; then
    [ "$trust_oid" = "$CURRENT_TRUST_TIP" ] || error "commit $commit trust_oid $trust_oid does not match current trust $CURRENT_TRUST_TIP"
  else
    # If trust is missing and allowed, do not enforce trust_oid equality.
    if [ "$ALLOW_MISSING_TRUST" != "1" ]; then
      error "trust ref $TRUST_REF missing"
    fi
  fi
  [[ "$seq" =~ ^[0-9]+$ ]] || error "commit $commit has invalid seq"
  [ -n "$status" ] || error "commit $commit missing status"

  local actual_parent
  actual_parent=$(git show -s --format='%P' "$commit")
  if [ -z "$actual_parent" ]; then
    actual_parent=""
  fi
  if [[ "$actual_parent" =~ \  ]]; then
    error "commit $commit is a merge; journal entries must be linear"
  fi

  if [ -z "$actual_parent" ]; then
    [ "$declared_parent" = "" ] || error "commit $commit declared parent $declared_parent but has none"
    [ "$seq" -eq 0 ] || error "commit $commit must have seq 0 for initial entry"
  else
    [ "$declared_parent" = "$actual_parent" ] || error "commit $commit parent mismatch (declared $declared_parent vs actual $actual_parent)"
    local prev_seq
    prev_seq=$(get_commit_seq "$actual_parent") || error "parent commit $actual_parent missing seq"
    [[ "$prev_seq" =~ ^[0-9]+$ ]] || error "parent commit $actual_parent has invalid seq"
    local expected
    expected=$((prev_seq + 1))
    [ "$seq" -eq "$expected" ] || error "commit $commit seq $seq expected $expected"
  fi

  local author
  author=$(git show -s --format='%ae' "$commit")
  ensure_author_allowed "$author" "$allowlist"
  ensure_commit_signed_if_required "$commit" "$require_signed"
}

validate_journal_updates() {
  local env="$1" old="$2" new="$3"
  ensure_fast_forward "$old" "$new" "refs/_shiplog/journal/$env"
  local require_signed allowlist
  if [ -n "$CURRENT_POLICY_JSON" ]; then
    require_signed=$(get_policy_require_signed "$env")
    allowlist=$(get_policy_authors "$env")
  else
    if [ "$ALLOW_MISSING_POLICY" = "1" ]; then
      require_signed=false
      allowlist=""
    else
      error "policy ref $POLICY_REF missing"
    fi
  fi

  local range
  if [ "$old" = "0000000000000000000000000000000000000000" ]; then
    range="$new"
  else
    range="$new"" ""^$old"
  fi

  git rev-list --reverse $range | while read -r commit; do
    [ -n "$commit" ] || continue
    validate_journal_commit "$env" "$commit" "$require_signed" "$allowlist"
  done
}

CURRENT_TRUST_TIP=$(git rev-parse -q --verify "$TRUST_REF" 2>/dev/null || true)
if [ -n "$CURRENT_TRUST_TIP" ]; then
  load_trust_state "$CURRENT_TRUST_TIP"
else
  CURRENT_TRUST_JSON=""
  SIGNERS_FILE=""
fi

CURRENT_POLICY_TIP=$(git rev-parse -q --verify "$POLICY_REF" 2>/dev/null || true)
if [ -n "$CURRENT_POLICY_TIP" ]; then
  load_policy_state "$CURRENT_POLICY_TIP"
else
  CURRENT_POLICY_JSON=""
fi

while read -r old_sha new_sha refname; do
  if [ "$new_sha" = "0000000000000000000000000000000000000000" ]; then
    continue
  fi
  case "$refname" in
    "$TRUST_REF")
      validate_trust_update "$old_sha" "$new_sha"
      ;;
    "$POLICY_REF")
      validate_policy_update "$old_sha" "$new_sha"
      ;;
    refs/_shiplog/journal/*)
      env="${refname#refs/_shiplog/journal/}"
      validate_journal_updates "$env" "$old_sha" "$new_sha"
      ;;
    refs/_shiplog/anchors/*)
      ensure_fast_forward "$old_sha" "$new_sha" "$refname"
      ;;
    *)
      ;;
  esac
done

exit 0
