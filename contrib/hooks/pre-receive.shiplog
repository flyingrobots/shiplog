#!/usr/bin/env bash
set -euo pipefail

JQ_BIN="${SHIPLOG_JQ_BIN:-/usr/local/bin/jq}"
TRUST_REF="${SHIPLOG_TRUST_REF:-refs/_shiplog/trust/root}"
POLICY_REF="${SHIPLOG_POLICY_REF:-refs/_shiplog/policy/current}"
REQUIRE_SEPARATE_SIGNERS="${SHIPLOG_REQUIRE_SEPARATE_SIGNERS:-1}"
# Optional relaxations: allow missing trust/policy when signatures are not required.
# Defaults keep strict behavior for CI/tests.
ALLOW_MISSING_TRUST="${SHIPLOG_ALLOW_MISSING_TRUST:-0}"
ALLOW_MISSING_POLICY="${SHIPLOG_ALLOW_MISSING_POLICY:-0}"
HOOK_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
POLICY_VALIDATOR_BIN="${SHIPLOG_POLICY_VALIDATE_BIN:-}"
POLICY_VALIDATOR_FILTER="${SHIPLOG_POLICY_VALIDATOR:-}"
SEMVER_REGEX='^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(?:-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(?:\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$'

if ! command -v "$JQ_BIN" >/dev/null 2>&1; then
  if command -v jq >/dev/null 2>&1; then
    JQ_BIN="$(command -v jq)"
  else
    echo "shiplog pre-receive: jq not found at $JQ_BIN" >&2
    exit 1
  fi
fi

TMP_ROOT="$(mktemp -d)"
trap 'rm -rf "$TMP_ROOT"' EXIT
SIGNERS_FILE=""
CURRENT_TRUST_TIP=""
CURRENT_TRUST_JSON=""
CURRENT_POLICY_JSON=""

policy_validator_filter_content() {
  cat <<'JQ'
# jq filter to validate Shiplog policy JSON
def semver_pattern:
  "^(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)(?:-[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?(?:\\+[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?$";
def err($ok; $msg): if $ok then empty else $msg end;
def is_string_array: type=="array" and (all(.[]?; type=="string"));
def optional_ref($field; $msg): if has($field) then err((.[$field]|type=="string") and (.[$field]|startswith("refs/")); $msg) else empty end;
def authors_errors:
  if has("authors") then
    if (.authors|type=="object") then
      [ err((.authors|has("default_allowlist"))
             and (.authors.default_allowlist|is_string_array)
             and ((.authors.default_allowlist|length) > 0);
             "authors.default_allowlist: non-empty array of strings required when authors is present"),
        (if (.authors|has("env_overrides")) then
           if (.authors.env_overrides|type=="object") then
             (.authors.env_overrides | to_entries | map(err((.value|is_string_array);
                      "authors.env_overrides." + .key + ": array of strings required")))
           else
             ["authors.env_overrides: object required when present"]
           end
         else [] end)
      ] | flatten | map(select(. != null and . != ""))
    else
      ["authors.default_allowlist: non-empty array of strings required when authors is present"]
    end
  else []
  end;
def deployment_errors:
  if has("deployment_requirements") then
    if (.deployment_requirements|type=="object") then [] else ["deployment_requirements: object required"] end
  else []
  end;
[
  err((.version|type=="string") and (.version|test(semver_pattern)); "version: semver string (e.g. 1.0.0) required"),
  err((has("require_signed")|not) or (.require_signed|type=="boolean"); "require_signed: boolean required when present"),
  authors_errors[],
  deployment_errors[],
  optional_ref("notes_ref"; "notes_ref: must start with refs/"),
  optional_ref("journals_ref_prefix"; "journals_ref_prefix: must start with refs/"),
  optional_ref("anchors_ref_prefix"; "anchors_ref_prefix: must start with refs/")
]
| map(select(. != null and . != ""))
| .[]
JQ
}

find_policy_validator_bin() {
  local candidates=(
    "$POLICY_VALIDATOR_BIN"
    "${SHIPLOG_HOME:-}/scripts/policy/validate.sh"
    "$HOOK_DIR/../policy/validate.sh"
    "$HOOK_DIR/policy/validate.sh"
  )
  local candidate
  for candidate in "${candidates[@]}"; do
    if [ -n "$candidate" ] && [ -x "$candidate" ]; then
      printf '%s' "$candidate"
      return 0
    fi
  done
  return 1
}

ensure_policy_validator_filter() {
  local filter="${POLICY_VALIDATOR_FILTER}"
  if [ -n "$filter" ] && [ -f "$filter" ]; then
    printf '%s' "$filter"
    return 0
  fi
  local candidates=(
    "${SHIPLOG_HOME:-}/scripts/lib/policy_validate.jq"
    "$HOOK_DIR/../lib/policy_validate.jq"
    "$HOOK_DIR/policy_validate.jq"
  )
  local candidate
  for candidate in "${candidates[@]}"; do
    if [ -n "$candidate" ] && [ -f "$candidate" ]; then
      printf '%s' "$candidate"
      return 0
    fi
  done
  filter="$TMP_ROOT/policy_validate.jq"
  policy_validator_filter_content > "$filter"
  printf '%s' "$filter"
}

run_policy_validator() {
  local json="$1"
  local validator
  if validator=$(find_policy_validator_bin); then
    local output=""
    if ! output=$(printf '%s\n' "$json" | "$validator" --stdin 2>&1); then
      [ -n "$output" ] && dbg "$output"
      error "policy.json failed validation"
    fi
    return 0
  fi
  local filter
  filter=$(ensure_policy_validator_filter)
  local errors
  errors=$(printf '%s\n' "$json" | "$JQ_BIN" -r -f "$filter" 2>/dev/null || true)
  if [ -n "$errors" ]; then
    dbg "$errors"
    error "policy.json failed validation"
  fi
}

error() {
  echo "❌ shiplog: $*" >&2
  exit 1
}

debug_enabled() {
  case "$(printf '%s' "${SHIPLOG_DEBUG_SSH_VERIFY:-0}" | tr '[:upper:]' '[:lower:]')" in
    1|true|yes|on) return 0 ;;
    *) return 1 ;;
  esac
}
dbg() { debug_enabled && echo "shiplog[debug]: $*" >&2 || true; }

load_trust_state() {
  local commit="$1"
  [ -n "$commit" ] || return 0
  CURRENT_TRUST_TIP="$commit"
  CURRENT_TRUST_JSON=$(git show "$commit:trust.json" 2>/dev/null || true)
  [ -n "$CURRENT_TRUST_JSON" ] || error "trust ref $TRUST_REF is missing trust.json"
  "$JQ_BIN" -e '
    .version == 1 and
    (.threshold | type == "number" and . >= 1) and
    (.maintainers | type == "array" and length >= 1)
  ' <<<"$CURRENT_TRUST_JSON" >/dev/null 2>&1 || error "trust.json failed validation"

  local signers_blob
  signers_blob=$(git show "$commit:allowed_signers" 2>/dev/null || true)
  if [ "$REQUIRE_SEPARATE_SIGNERS" = "1" ]; then
    [ -n "$signers_blob" ] || error "trust ref $TRUST_REF missing allowed_signers"
  fi
  if [ -n "$signers_blob" ]; then
    SIGNERS_FILE="$TMP_ROOT/allowed_signers"
    printf '%s' "$signers_blob" > "$SIGNERS_FILE"
    chmod 600 "$SIGNERS_FILE"
    if debug_enabled; then
      principals=$(awk '{print $1}' "$SIGNERS_FILE" | paste -sd, -)
      dbg "allowed_signers principals=[${principals}]"
    fi
  else
    SIGNERS_FILE=""
  fi
}

load_policy_state() {
  local commit="$1"
  [ -n "$commit" ] || return 0
  CURRENT_POLICY_JSON=$(git show "$commit:.shiplog/policy.json" 2>/dev/null || true)
  [ -n "$CURRENT_POLICY_JSON" ] || return 0
  run_policy_validator "$CURRENT_POLICY_JSON"
}


get_policy_require_signed() {
  local env="$1"
  "$JQ_BIN" -r --arg env "$env" '(.deployment_requirements[$env].require_signed // .require_signed // false) | tostring' <<<"$CURRENT_POLICY_JSON"
}

get_policy_authors() {
  local env="$1"
  "$JQ_BIN" -r --arg env "$env" '
    if (.authors.default_allowlist? != null or .authors.env_overrides?) then
      [
        (.authors.default_allowlist // []),
        (.authors.env_overrides.default // []),
        (.authors.env_overrides[$env] // [])
      ]
    else
      [
        (.authors.default // []),
        (.authors[$env] // []),
        (.authors.env_overrides.default // []),
        (.authors.env_overrides[$env] // [])
      ]
    end
    | flatten
    | map(select(. != null and . != ""))
    | unique
    | join(" ")
  ' <<<"$CURRENT_POLICY_JSON"
}

ensure_fast_forward() {
  local old="$1" new="$2" ref="$3"
  if [ "$old" = "0000000000000000000000000000000000000000" ]; then
    return 0
  fi
  git merge-base --is-ancestor "$old" "$new" >/dev/null 2>&1 || error "$ref is not a fast-forward update"
}

validate_trust_update() {
  local old="$1" new="$2"
  ensure_fast_forward "$old" "$new" "$TRUST_REF"
  load_trust_state "$new"
  # Run shared verifier if available (preferred for both modes)
  if [ -x "$GIT_DIR/../scripts/shiplog-verify-trust.sh" ]; then
    (cd "$GIT_DIR/.." && ./scripts/shiplog-verify-trust.sh --old "$old" --new "$new" --ref "$TRUST_REF") || error "trust verification failed"
  else
    # Fallback: require at least one valid signature and block threshold>1 by default
    enforce_trust_threshold "$new"
  fi
}

validate_policy_update() {
  local old="$1" new="$2"
  ensure_fast_forward "$old" "$new" "$POLICY_REF"
load_policy_state "$new"
}

# Enforce that the new trust commit is properly signed and (eventually) co-signed
enforce_trust_threshold() {
  local commit="$1"
  # Trust-commit signature gate:
  # - SHIPLOG_REQUIRE_SIGNED_TRUST defaults to 0 (signature checks skipped)
  # - For production, set to 1/true/yes/on to enforce signed trust commits
  #   (leaving it off reduces integrity of trust updates)
  # Normalize gate safely under set -u
  local gate gate_mode
  gate=$(printf '%s' "${SHIPLOG_REQUIRE_SIGNED_TRUST:-0}" | tr '[:upper:]' '[:lower:]')
  gate_mode=$(printf '%s' "${SHIPLOG_REQUIRE_SIGNED_TRUST_MODE:-commit}" | tr '[:upper:]' '[:lower:]')
  local gpg_format="${SHIPLOG_GPG_FORMAT:-ssh}"
  dbg "require_signed: enabled=$gate mode=$gate_mode gpg.format=$gpg_format"
  local commit_ok=0 commit_checked=0
  case "$gate" in
    1|true|yes|on)
      case "$gate_mode" in
        commit)
          commit_checked=1
          if [ -n "$SIGNERS_FILE" ]; then
            if GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed; signature block follows"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
              error "trust commit $commit has missing or invalid signature"
            fi
          else
            if git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed (no allowed_signers); signature block follows"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
              error "trust commit $commit failed signature verification"
            fi
          fi
          ;;
        either)
          commit_checked=1
          if [ -n "$SIGNERS_FILE" ]; then
            if GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed under 'either'; will attempt attestation fallback if applicable"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
            fi
          else
            if git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
              commit_ok=1
            else
              dbg "git verify-commit failed under 'either' (no allowed_signers)"
              dbg "$(git log -1 --show-signature --pretty=medium "$commit" 2>/dev/null || true)"
            fi
          fi
          ;;
        attestation)
          : ;; # handled below
        *)
          dbg "unknown SHIPLOG_REQUIRE_SIGNED_TRUST_MODE=$gate_mode; defaulting to commit"
          commit_checked=1
          if ! git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1; then
            error "trust commit $commit failed signature verification"
          fi
          commit_ok=1
          ;;
      esac
      ;;
    *) : ;;
  esac

  # Enforce threshold semantics progressively.
  # NOTE: Git commits carry a single embedded signature. Multi-maintainer co-signing requires a
  # higher-level pattern (e.g., a linear chain of N commits over the same tree, or detached
  # attestations stored in the trust tree). Until that is implemented, we fail closed by default
  # when threshold > 1, with an escape hatch for staged rollouts.
  local threshold
  threshold=$(printf '%s' "$CURRENT_TRUST_JSON" | "$JQ_BIN" -r '.threshold // 1')
  case "$threshold" in
    ''|null) threshold=1 ;;
  esac
  if ! printf '%s' "$threshold" | grep -Eq '^[1-9][0-9]*$'; then
    error "trust.json invalid threshold value: $threshold"
  fi

  if [ "$threshold" -gt 1 ]; then
    if [ "${SHIPLOG_ALLOW_TRUST_THRESHOLD_UNENFORCED:-0}" != "1" ]; then
      # Attempt minimal attestation enforcement if requested or as 'either' fallback
      if [ "$gate_mode" = "attestation" ] || { [ "$gate_mode" = "either" ] && [ "$commit_checked" = "1" ] && [ "$commit_ok" != "1" ]; }; then
        attestation_verify "$commit" "$threshold" || error "verified fewer than $threshold attestations"
        return 0
      fi
      error "trust threshold $threshold not yet enforced by hook; set SHIPLOG_ALLOW_TRUST_THRESHOLD_UNENFORCED=1 to allow temporarily"
    fi
  fi
  # If threshold==1 and commit verification did not succeed (or attestation mode is explicitly
  # requested), attempt attestation verification as the decision-maker for this update.
  # This ensures SHIPLOG_REQUIRE_SIGNED_TRUST_MODE=attestation enforces attestations even when
  # the commit signature is absent or unaccepted.
  if [ "$threshold" -eq 1 ]; then
    if { [ "$commit_checked" = "1" ] && [ "$commit_ok" != "1" ]; } || [ "$gate_mode" = "attestation" ]; then
      attestation_verify "$commit" 1 || error "no valid attestation found for threshold=1"
    fi
  fi
}

# Minimal attestation verification for the fallback path in this hook
attestation_verify() {
  local commit="$1" threshold="$2"
  command -v ssh-keygen >/dev/null 2>&1 || return 1
  [ -n "$SIGNERS_FILE" ] || return 1
  # Collect attestation sigs under .shiplog/trust_sigs/
  mapfile -t sigs < <(git ls-tree -r --name-only "$commit" | awk '/^\.shiplog\/trust_sigs\//{print}')
  local nsigs=${#sigs[@]}
  dbg "attestation(fallback): found $nsigs signature file(s)"
  [ "$nsigs" -ge 1 ] || return 1
  # Build canonical base payload
  local oid_trust oid_sigs base trust_id tmp_in verified=0 principals_seen=""
  trust_id=$(printf '%s' "$CURRENT_TRUST_JSON" | "$JQ_BIN" -r '.id // "shiplog-trust-root"')
  oid_trust=$(git ls-tree "$commit" trust.json | awk '{print $3}')
  oid_sigs=$(git ls-tree "$commit" allowed_signers | awk '{print $3}')
  if [ -n "$oid_sigs" ]; then
    base=$(printf '100644 blob %s\ttrust.json\n100644 blob %s\tallowed_signers\n' "$oid_trust" "$oid_sigs" | git mktree)
  else
    base=$(printf '100644 blob %s\ttrust.json\n' "$oid_trust" | git mktree)
  fi
  tmp_in=$(mktemp)
  printf 'shiplog-trust-tree-v1\n%s\n%s\n%s\n' "$base" "$trust_id" "$threshold" >"$tmp_in"
  for path in "${sigs[@]}"; do
    principal=$(basename "$path" | sed 's/\.sig$//')
    sigblob=$(git show "$commit:$path" 2>/dev/null || true)
    [ -n "$sigblob" ] || continue
    sigfile=$(mktemp)
    printf '%s' "$sigblob" > "$sigfile"
    if ssh-keygen -Y verify -n shiplog-trust -f "$SIGNERS_FILE" -I "$principal" -s "$sigfile" < "$tmp_in" >/dev/null 2>&1; then
      case " $principals_seen " in *" $principal "*) : ;; *) principals_seen="$principals_seen $principal"; verified=$((verified+1));; esac
    fi
    rm -f "$sigfile"
  done
  rm -f "$tmp_in"
  dbg "attestation(fallback): verified=$verified threshold=$threshold"
  [ "$verified" -ge "$threshold" ]
}

read_commit_json() {
  local commit="$1"
  git show -s --format=%B "$commit" | awk '/^---/{flag=1;next}flag'
}

get_commit_seq() {
  local commit="$1"
  local json
  json=$(read_commit_json "$commit") || return 1
  [ -n "$json" ] || return 1
  "$JQ_BIN" -r '.seq' <<<"$json"
}

ensure_author_allowed() {
  local author="$1" allowlist="$2"
  [ -z "$allowlist" ] && return 0
  for entry in $allowlist; do
    [ "$entry" = "$author" ] && return 0
  done
  error "author <$author> not allowed for journal"
}

ensure_commit_signed_if_required() {
  local commit="$1" require_signed="$2"
  if [ "$require_signed" != "true" ] && [ "$require_signed" != "1" ]; then
    return 0
  fi
  if ! git cat-file commit "$commit" | grep -q '^gpgsig ' ; then
    error "commit $commit missing required signature"
  fi
  local gpg_format="${SHIPLOG_GPG_FORMAT:-ssh}"
  if [ -n "$SIGNERS_FILE" ]; then
    GIT_SSH_ALLOWED_SIGNERS="$SIGNERS_FILE" git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1 || error "signature for $commit not accepted"
  else
    git -c gpg.format="$gpg_format" verify-commit "$commit" >/dev/null 2>&1 || error "signature verification failed for $commit"
  fi
}

validate_journal_commit() {
  local env="$1" commit="$2" require_signed="$3" allowlist="$4"
  local json
  json=$(read_commit_json "$commit")
  [ -n "$json" ] || error "commit $commit missing structured trailer"

  local declared_env declared_parent seq trust_oid status
  declared_env=$("$JQ_BIN" -r '.env // empty' <<<"$json")
  seq=$("$JQ_BIN" -r '.seq' <<<"$json")
  trust_oid=$("$JQ_BIN" -r '.trust_oid // empty' <<<"$json")
  declared_parent=$("$JQ_BIN" -r '.journal_parent // ""' <<<"$json")
  status=$("$JQ_BIN" -r '.status // empty' <<<"$json")

  [ "$declared_env" = "$env" ] || error "commit $commit declares env $declared_env but ref is $env"
  if [ -n "$CURRENT_TRUST_TIP" ]; then
    [ "$trust_oid" = "$CURRENT_TRUST_TIP" ] || error "commit $commit trust_oid $trust_oid does not match current trust $CURRENT_TRUST_TIP"
  else
    # If trust is missing and allowed, do not enforce trust_oid equality.
    if [ "$ALLOW_MISSING_TRUST" != "1" ]; then
      error "trust ref $TRUST_REF missing"
    fi
  fi
  [[ "$seq" =~ ^[0-9]+$ ]] || error "commit $commit has invalid seq"
  [ -n "$status" ] || error "commit $commit missing status"

  local actual_parent
  actual_parent=$(git show -s --format='%P' "$commit")
  if [ -z "$actual_parent" ]; then
    actual_parent=""
  fi
  if [[ "$actual_parent" =~ \  ]]; then
    error "commit $commit is a merge; journal entries must be linear"
  fi

  if [ -z "$actual_parent" ]; then
    [ "$declared_parent" = "" ] || error "commit $commit declared parent $declared_parent but has none"
    [ "$seq" -eq 0 ] || error "commit $commit must have seq 0 for initial entry"
  else
    [ "$declared_parent" = "$actual_parent" ] || error "commit $commit parent mismatch (declared $declared_parent vs actual $actual_parent)"
    local prev_seq
    prev_seq=$(get_commit_seq "$actual_parent") || error "parent commit $actual_parent missing seq"
    [[ "$prev_seq" =~ ^[0-9]+$ ]] || error "parent commit $actual_parent has invalid seq"
    local expected
    expected=$((prev_seq + 1))
    [ "$seq" -eq "$expected" ] || error "commit $commit seq $seq expected $expected"
  fi

  local author
  author=$(git show -s --format='%ae' "$commit")
  ensure_author_allowed "$author" "$allowlist"
  ensure_commit_signed_if_required "$commit" "$require_signed"
}

validate_journal_updates() {
  local env="$1" old="$2" new="$3"
  ensure_fast_forward "$old" "$new" "refs/_shiplog/journal/$env"
  local require_signed allowlist
  if [ -n "$CURRENT_POLICY_JSON" ]; then
    require_signed=$(get_policy_require_signed "$env")
    allowlist=$(get_policy_authors "$env")
  else
    if [ "$ALLOW_MISSING_POLICY" = "1" ]; then
      require_signed=false
      allowlist=""
    else
      error "policy ref $POLICY_REF missing"
    fi
  fi

  local range
  if [ "$old" = "0000000000000000000000000000000000000000" ]; then
    range="$new"
  else
    range="$new"" ""^$old"
  fi

  git rev-list --reverse $range | while read -r commit; do
    [ -n "$commit" ] || continue
    validate_journal_commit "$env" "$commit" "$require_signed" "$allowlist"
  done
}

CURRENT_TRUST_TIP=$(git rev-parse -q --verify "$TRUST_REF" 2>/dev/null || true)
if [ -n "$CURRENT_TRUST_TIP" ]; then
  load_trust_state "$CURRENT_TRUST_TIP"
else
  CURRENT_TRUST_JSON=""
  SIGNERS_FILE=""
fi

CURRENT_POLICY_TIP=$(git rev-parse -q --verify "$POLICY_REF" 2>/dev/null || true)
if [ -n "$CURRENT_POLICY_TIP" ]; then
  load_policy_state "$CURRENT_POLICY_TIP"
else
  CURRENT_POLICY_JSON=""
fi

while read -r old_sha new_sha refname; do
  if [ "$new_sha" = "0000000000000000000000000000000000000000" ]; then
    continue
  fi
  case "$refname" in
    "$TRUST_REF")
      validate_trust_update "$old_sha" "$new_sha"
      ;;
    "$POLICY_REF")
      validate_policy_update "$old_sha" "$new_sha"
      ;;
    refs/_shiplog/journal/*)
      env="${refname#refs/_shiplog/journal/}"
      validate_journal_updates "$env" "$old_sha" "$new_sha"
      ;;
    refs/_shiplog/anchors/*)
      ensure_fast_forward "$old_sha" "$new_sha" "$refname"
      ;;
    *)
      ;;
  esac
done

exit 0
