#!/usr/bin/env bash
# bosun — bash-only TUI helpers (confirm/input/choose/style/table/spin)
# No deps. Honors NO_COLOR. Works in CI (non-TTY) and interactive shells.

set -Eeuo pipefail

die() {
  printf 'bosun: %s\n' "$*" >&2
  exit 64
}

canonical_dir() {
  local path="$1"
  [ -n "$path" ] || return 1
  if ! (cd "$path" 2>/dev/null); then
    return 1
  fi
  pwd -P
}

strip_ansi() {
  if command -v perl >/dev/null 2>&1; then
    perl -pe 's/\e\[[0-9;]*[0-9A-PR-TZcf-nq-uy=><]//g; s/\e\][^\a]*(\a|\e\\)//g; s/\e[P^_].*?\e\\//g'
    return 0
  fi
  # Fallback: no-op if perl unavailable. Tests assert content, not styling.
  cat
}

BOSUN_SELF="${BASH_SOURCE[0]:-$0}"
BOSUN_DIR="$(cd "$(dirname "$BOSUN_SELF")" && pwd)"
SHIPLOG_HOME="${SHIPLOG_HOME:-$(cd "$BOSUN_DIR/.." && pwd)}"

_resolve_doc_root() {
  local candidate="$1"
  local resolved
  resolved=$(canonical_dir "$candidate") || die "invalid BOSUN_DOC_ROOT: $candidate"
  [ -d "$resolved" ] || die "BOSUN_DOC_ROOT does not exist or is not a directory: $resolved"
  printf '%s' "$resolved"
}

if [ -n "${BOSUN_DOC_ROOT:-}" ]; then
  BOSUN_DOC_ROOT=$(_resolve_doc_root "$BOSUN_DOC_ROOT")
else
  BOSUN_DOC_ROOT=$(_resolve_doc_root "$BOSUN_DIR/../docs/bosun")
fi

trim_space() {
  printf '%s' "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

bosun_version() {
  if [ -n "${BOSUN_VERSION:-}" ]; then
    printf '%s' "$BOSUN_VERSION"
    return
  fi
  if command -v git >/dev/null 2>&1 && git -C "$SHIPLOG_HOME" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local desc
    desc=$(git -C "$SHIPLOG_HOME" describe --tags --always 2>/dev/null || true)
    if [ -n "$desc" ]; then
      printf '%s' "$desc"
      return
    fi
    desc=$(git -C "$SHIPLOG_HOME" rev-parse --short HEAD 2>/dev/null || true)
    if [ -n "$desc" ]; then
      printf '%s' "$desc"
      return
    fi
  fi
  printf '%s' "unknown"
}

show_doc() {
  local topic="$1" doc
  doc="$BOSUN_DOC_ROOT/$topic.md"
  if [ -r "$doc" ]; then
    cat "$doc"
    return 0
  fi
  return 1
}

# ---- TTY & Color ------------------------------------------------------------
is_tty() {
  if [ "${BOSUN_FORCE_TTY:-0}" = "1" ]; then
    return 0
  fi
  [ -t 0 ] && [ -t 1 ]
}
ansi() {
  local on="${BOSUN_NO_COLOR:-0}"
  [ -n "${NO_COLOR:-}" ] && on=1
  [ "${on}" = "1" ] && return 0
  [ -n "$1" ] && printf '\033[%sm' "$1"
}
color() { ansi "$1"; shift; printf '%s' "$*"; ansi '0'; }

# ---- JSON helper ------------------------------------------------------------
json_escape() {
  local data
  data=$(cat)
  if command -v jq >/dev/null 2>&1; then
    local enc
    enc=$(printf '%s' "$data" | jq -Rs @json 2>/dev/null || true)
    if [ -n "$enc" ]; then
      if [ "${enc:0:1}" = '"' ]; then
        enc=${enc#?}
      fi
      if [ "${enc: -1}" = '"' ]; then
        enc=${enc%?}
      fi
      printf '%s' "$enc"
      return 0
    fi
  fi

  local fallback
  fallback=$(printf '%s' "$data" | sed -e 's/\\\\/\\\\\\\\/g' \
                                 -e 's/"/\\"/g' \
                                 -e 's/\r/\\r/g' \
                                 -e 's/\t/\\t/g' \
                                 -e 's/\f/\\f/g' \
                                 -e 's/\b/\\b/g' \
                                 -e 's/\n/\\n/g')
  printf '%s' "$fallback"
}
emit_json_kv() {
  printf '{"%s":' "$1"
  if [ "$2" = "true" ] || [ "$2" = "false" ] || [[ "$2" =~ ^-?(0|[1-9][0-9]*)$|^-?(0|[1-9][0-9]*)\.[0-9]+([eE][+-]?[0-9]+)?$ ]]; then
    printf '%s' "$2"
  else
    printf '"%s"' "$(printf '%s' "$2" | json_escape)"
  fi
  printf '}\n'
}

# ---- UI primitives ----------------------------------------------------------
draw_box() {
  local title_col="$1"; shift
  local text="$*"
  local width="${BOSUN_WIDTH:-80}"
  local inner=$((width-4))
  local border_top="─" corner_tl="┌" corner_tr="┐"
  local border_side="│" corner_bl="└" corner_br="┘"
  [ "$inner" -lt 1 ] && inner=1
  local title_raw
  title_raw="$(printf '%s' "$title_col" | strip_ansi)"
  if [ -n "$title_raw" ]; then
    local barlen=$(( width - ${#title_raw} - 4 ))
    [ "$barlen" -lt 0 ] && barlen=0
    printf "%s %s %s%s\n" "${corner_tl}" "$title_col" "$(printf '%*s' "$barlen" '' | tr ' ' "$border_top")" "${corner_tr}"
  else
    printf "%s%s%s\n" "${corner_tl}" "$(printf '%*s' $((width-2)) '' | tr ' ' "$border_top")" "${corner_tr}"
  fi
  local line chunk
  while IFS= read -r line; do
    while [ "${#line}" -gt "$inner" ]; do
      chunk="${line:0:$inner}"
      printf "%s %-*s %s\n" "${border_side}" "$inner" "$chunk" "${border_side}"
      line="${line:$inner}"
    done
    printf "%s %-*s %s\n" "${border_side}" "$inner" "$line" "${border_side}"
  done <<< "$text"
  printf "%s%s%s\n" "${corner_bl}" "$(printf '%*s' $((width-2)) '' | tr ' ' "$border_top")" "${corner_br}"
}

# ---- Commands ---------------------------------------------------------------
cmd_confirm() {
  local yes=0 json=0 def_yes=0
  while [ $# -gt 0 ]; do
    case "$1" in
      --yes|-y) yes=1 ;;
      --default-yes) def_yes=1 ;;
      --json) json=1 ;;
      --no-color) BOSUN_NO_COLOR=1 ;;
      --) shift; break ;;
      *) break ;;
    esac; shift
  done
  local prompt="${*:-Are you sure?}"
  if [ "$yes" -eq 1 ]; then
    [ "$json" -eq 1 ] && emit_json_kv ok true || echo "yes"; return 0
  fi
  if ! is_tty; then
    if [ "$def_yes" -eq 1 ]; then
      [ "$json" -eq 1 ] && emit_json_kv ok true || echo "yes"; return 0
    else
      [ "$json" -eq 1 ] && emit_json_kv ok false || echo "no"; return 1
    fi
  fi
  local hint="[y/N]"; [ "$def_yes" -eq 1 ] && hint="[Y/n]"
  local prompt_col
  prompt_col=$(color '1;36' "$prompt $hint ")
  printf '%s' "$prompt_col"
  local ans=""
  IFS= read -r -n 1 ans || true
  printf '\n'
  case "$(printf '%s' "$ans" | tr '[:upper:]' '[:lower:]')" in
    y) [ "$json" -eq 1 ] && emit_json_kv ok true || echo "yes"; return 0 ;;
    n) [ "$json" -eq 1 ] && emit_json_kv ok false || echo "no"; return 1 ;;
    "") if [ "$def_yes" -eq 1 ]; then [ "$json" -eq 1 ] && emit_json_kv ok true || echo "yes"; return 0; else [ "$json" -eq 1 ] && emit_json_kv ok false || echo "no"; return 1; fi ;;
    *) [ "$json" -eq 1 ] && emit_json_kv ok false || echo "no"; return 1 ;;
  esac
}

cmd_input() {
  local placeholder="" def="" json=0
  while [ $# -gt 0 ]; do
    case "$1" in
      --placeholder) placeholder="$2"; shift ;;
      --value|--default) def="$2"; shift ;;
      --json) json=1 ;;
      --no-color) BOSUN_NO_COLOR=1 ;;
      --) shift; break ;;
      *) break ;;
    esac; shift
  done
  local prompt="${placeholder:->}"
  local out
  if is_tty; then
    local prompt_col
    prompt_col=$(color '1;33' "$prompt ")
    printf '%s' "$prompt_col"
    read -r out || true
  else
    # Non-interactive: avoid blocking when stdin is not a pipe or has no data
    if [ -p /dev/stdin ]; then
      out="$(cat - 2>/dev/null || true)"
    elif [ -s /dev/stdin ]; then
      out="$(cat - 2>/dev/null || true)"
    else
      out=""
    fi
  fi
  [ -z "$out" ] && out="$def"
  [ "$json" -eq 1 ] && emit_json_kv value "$out" || printf '%s\n' "$out"
}

cmd_choose() {
  local header="" json=0 def=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --header) header="$2"; shift ;;
      --json) json=1 ;;
      --default) def="$2"; shift ;;
      --no-color) BOSUN_NO_COLOR=1 ;;
      --) shift; break ;;
      *) break ;;
    esac; shift
  done
  local opts=("$@")
  if [ ${#opts[@]} -eq 0 ]; then
    echo "bosun choose: no options" >&2; return 2
  fi
  if ! is_tty; then
    local pick="${def:-${opts[0]}}"
    [ "$json" -eq 1 ] && emit_json_kv value "$pick" || echo "$pick"
    return 0
  fi
  if [ -n "$header" ]; then
    local header_col
    header_col=$(color '1;36' "$header")
    echo "$header_col"
  fi
  local i=1 o
  for o in "${opts[@]}"; do
    local option_idx
    option_idx=$(color '1;35' "$i")
    printf "  %s) %s\n" "$option_idx" "$o"
    i=$((i+1))
  done
  local sel
  local prompt_arrow
  prompt_arrow=$(color '1;33' '> ')
  printf '%s' "$prompt_arrow"
  read -r sel || true
  if [[ "$sel" =~ ^[1-9][0-9]*$|^[1-9]$ ]] && [ "$sel" -ge 1 ] && [ "$sel" -le ${#opts[@]} ]; then
    local pick="${opts[$((sel-1))]}"
    [ "$json" -eq 1 ] && emit_json_kv value "$pick" || echo "$pick"
    return 0
  fi
  echo "invalid selection" >&2; return 1
}

cmd_style() {
  local title=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --title) title="$2"; shift ;;
      --no-color) BOSUN_NO_COLOR=1 ;;
      --width) BOSUN_WIDTH="$2"; shift ;;
      --) shift; break ;;
      *) break ;;
    esac; shift
  done
  local text="$*"
  [ -z "$text" ] && text="$(cat - 2>/dev/null || echo)"
  local title_col
  title_col=$(color '1;34' "$title")
  draw_box "$title_col" "$text"
}

cmd_table() {
  local columns_arg="" rows_file=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --columns) columns_arg="$2"; shift ;;
      --rows-file) rows_file="$2"; shift ;;
      --no-color) BOSUN_NO_COLOR=1 ;;
      --width) BOSUN_WIDTH="$2"; shift ;;
      --) shift; break ;;
      *) break ;;
    esac; shift
  done
  [ -n "$columns_arg" ] || { echo "bosun table: --columns required" >&2; return 2; }

  local headers=()
  local h
  local IFS=','
  read -r -a headers <<< "$columns_arg"
  local canonical_headers=()
  for h in "${headers[@]}"; do
    local trimmed
    trimmed=$(trim_space "$h")
    [ -n "$trimmed" ] || { echo "bosun table: empty column name" >&2; return 2; }
    canonical_headers+=("$trimmed")
  done
  headers=("${canonical_headers[@]}")

  local rows=()
  if [ -n "$rows_file" ]; then
    if [ ! -r "$rows_file" ]; then
      echo "bosun table: unable to read $rows_file" >&2
      return 2
    fi
    while IFS= read -r line || [ -n "$line" ]; do
      rows+=("$line")
    done < "$rows_file"
  else
    while IFS= read -r line || [ -n "$line" ]; do
      rows+=("$line")
    done
  fi

  local -a widths=()
  local idx
  for idx in "${!headers[@]}"; do
    widths[$idx]=${#headers[$idx]}
  done

  local row
  local SEP=$'\x1F'
  local -a parsed_rows=()
  local row
  for row in "${rows[@]}"; do
    [ -n "$row" ] || continue
    local IFS=$'\t'
    read -r -a split_result <<< "$row"
    if [ ${#split_result[@]} -ne ${#headers[@]} ]; then
      echo "bosun table: row has ${#split_result[@]} columns but expected ${#headers[@]}" >&2
      return 3
    fi
    local joined=""
    for idx in "${!split_result[@]}"; do
      local col="${split_result[$idx]}"
      if [ ${#col} -gt ${widths[$idx]} ]; then
        widths[$idx]=${#col}
      fi
      if [ $idx -eq 0 ]; then
        joined+="$col"
      else
        joined+="$SEP$col"
      fi
    done
    parsed_rows+=("$joined")
  done

  local header_text border_text
  for idx in "${!headers[@]}"; do
    header_text=$(printf '%-*s' "${widths[$idx]}" "${headers[$idx]}")
    printf '%s' "$(color '1;37' "$header_text")"
    [ "$idx" -lt $((${#headers[@]}-1)) ] && printf '  '
  done
  printf '\n'

  for idx in "${!headers[@]}"; do
    border_text=$(printf '%-*s' "${widths[$idx]}" '' | tr ' ' '─')
    printf '%s' "$border_text"
    [ "$idx" -lt $((${#headers[@]}-1)) ] && printf '  '
  done
  printf '\n'

  for entry in "${parsed_rows[@]}"; do
    local IFS=$'\x1F'
    read -r -a split_result <<< "$entry"
    for idx in "${!split_result[@]}"; do
      printf '%-*s' "${widths[$idx]}" "${split_result[$idx]}"
      [ "$idx" -lt $((${#split_result[@]}-1)) ] && printf '  '
    done
    printf '\n'
  done
}

cmd_spin() {
  local title=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --title) title="$2"; shift ;;
      --no-color) BOSUN_NO_COLOR=1 ;;
      --) shift; break ;;
      *) break ;;
    esac; shift
  done
  local cmd=( "$@" )
  [ ${#cmd[@]} -gt 0 ] || { echo "bosun spin: no command specified" >&2; return 2; }

  if ! is_tty; then
    "${cmd[@]}"
    return $?
  fi

  local frames='-\|/' i=0 pid rc glyph
  "${cmd[@]}" & pid=$!
  if ! kill -0 "$pid" 2>/dev/null; then
    wait "$pid" 2>/dev/null || true
    return $?
  fi
  trap 'kill $pid 2>/dev/null || true' INT TERM
  while kill -0 "$pid" 2>/dev/null; do
    local frame_col
    frame_col=$(color '1;36' "${frames:i:1}")
    printf '\r%s %s' "$frame_col" "$title"
    i=$(( (i + 1) % ${#frames} ))
    sleep 0.1
  done
  trap - INT TERM
  wait "$pid"
  rc=$?
  if [ "$rc" -eq 0 ]; then
    glyph=$(color '1;32' '✔')
  else
    glyph=$(color '1;31' '✖')
  fi
  printf "\r%s %s\n" "$glyph" "$title"
  return "$rc"
}

usage() {
  if ! show_doc overview; then
    cat <<'EOF'
bosun — bash-only TUI helpers

Usage:
  bosun help [command]
  bosun --version
  bosun confirm [--yes] [--json] [--no-color] "Prompt"
  bosun input [--placeholder P] [--value V] [--json]
  bosun choose [--header H] [--default OPT] [--json] OPT1 OPT2 …
  bosun style [--title T] [--width N] [--no-color] -- "text"
  bosun table --columns "Col1,Col2" [--rows-file file.tsv]
  bosun spin --title "Doing X" -- <command>

Run "bosun help <command>" to see detailed documentation.
EOF
  fi
}

case "${1:-}" in
  --version|-V)
    echo "bosun $(bosun_version)"
    exit 0
    ;;
esac

sub="${1:-}"; shift || true

if [ -n "$sub" ]; then
  for arg in "$@"; do
    case "$arg" in
      -h|--help)
        if show_doc "$sub"; then
          exit 0
        else
          usage
          exit 64
        fi
        ;;
    esac
  done
fi

case "$sub" in
  version)
    echo "bosun $(bosun_version)"
    ;;
  confirm) cmd_confirm "$@";;
  input)   cmd_input "$@";;
  choose)  cmd_choose "$@";;
  style)   cmd_style "$@";;
  table)   cmd_table "$@";;
  spin)    cmd_spin "$@";;
  help)
    topic="${1:-overview}"
    if ! show_doc "$topic"; then
      echo "bosun: no documentation for '$topic'" >&2
      usage
      exit 64
    fi
    ;;
  ''|-h|--help) usage;;
  *) echo "bosun: unknown subcommand '$sub'" >&2; usage; exit 64;;
esac
